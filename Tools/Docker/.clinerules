# Cline Rules for this Directory

## Meta-Rule: Keep Rules Concise

**Description:**
When adding or modifying rules in this `.clinerules` file, prioritize clarity and conciseness. Ensure rules are actionable and directly address project standards or potential pitfalls without unnecessary verbosity.

**Rationale:**
A concise ruleset is easier to read, understand, and follow, maximizing its effectiveness.

---

**Important:** Before modifying files in this directory, please consult the following files for essential context:

-   **`ReadMe.md`**: Provides an overview of the project, the tools involved, and the purpose of each `Setup_*.ps1` script.
-   **`Requirements.md`**: Details the coding standards, common features (identified by two-letter codes), and specific implementation requirements for the PowerShell scripts. Understanding these requirements is crucial for maintaining consistency.

## Rule: Validate PowerShell Scripts After Modification

**Description:**
To maintain code quality and catch potential issues early, all PowerShell scripts (`*.ps1`) in this project should be validated using the `PSScriptAnalyzer` module after any modifications are made.

**Procedure:**
1. Ensure the `PSScriptAnalyzer` module is installed:
   `Install-Module -Name PSScriptAnalyzer -Scope CurrentUser -Force -Confirm:$false`
2. After modifying a `.ps1` file, run the analyzer on it:
   `Invoke-ScriptAnalyzer -Path .\path\to\your\script.ps1`
3. Review the output for any warnings or errors.
4. Address the identified issues before committing the changes. See the "Suppressing Acceptable Warnings" rule below for specific cases.

**Rationale:**
Using `PSScriptAnalyzer` helps enforce best practices, improve script reliability, and reduce potential runtime errors.

## Rule: Suppressing Acceptable PSScriptAnalyzer Warnings

**Description:**
While `PSScriptAnalyzer` is valuable, certain warnings might be acceptable or expected given the project structure, particularly in scripts utilizing the `Invoke-MenuLoop` pattern with shared state or generic function signatures.

**Acceptable Suppressions:**

*   **`PSAvoidGlobalVars`**: This warning often appears in the main menu scripts (`Setup_*.ps1` excluding `Setup_0_*.ps1`) because global variables (`$global:enginePath`, `$global:containerName`, etc.) are intentionally used to share state between different menu actions invoked via `Invoke-MenuLoop`. Suppressing this rule during validation of these specific scripts is acceptable.
*   **`PSReviewUnusedParameter`**: This warning can occur in script blocks passed to generic functions like `Update-Container`. The generic function might define a standard parameter signature for the script block (e.g., including `$ContainerEngineType`, `$ContainerName`), but a specific implementation of that script block might not use all provided parameters (e.g., if it relies on global variables instead). If the parameter is part of the required signature for the generic function, suppressing this warning for that specific parameter within the script block is acceptable. *Initially, attempts were made using `[SuppressMessageAttribute]`, but this did not work reliably within script blocks. Exclusion via command-line is preferred.*

**Procedure for Suppression (During Validation):**
When validating a script where these specific warnings are expected and acceptable, use the `-ExcludeRule` parameter with `Invoke-ScriptAnalyzer`.

**Example:**
To validate `Setup_3_n8n.ps1` while ignoring expected global variable usage and unused parameters in the update script block:
`Invoke-ScriptAnalyzer -Path .\Setup_3_n8n.ps1 -ExcludeRule PSAvoidGlobalVars, PSReviewUnusedParameter`

**Rationale:**
Suppressing these specific, understood warnings allows focusing on other potentially critical issues identified by the analyzer without being cluttered by expected noise inherent in the chosen design pattern (menu loop with shared state, generic function callbacks). Always ensure the suppression is justified and documented if necessary.

## Rule: Avoid Adding Temporary/Explanatory Comments to Code

**Description:**
When modifying code (e.g., replacing functions, fixing errors, removing whitespace), do not add comments into the code itself that explain the modification action (e.g., `# Replaced Write-Host`, `# Removed trailing whitespace`, `# Fixed syntax error`). Such comments are temporary artifacts of the development/debugging process and should not be part of the final committed code. **Specifically, when using tools like `replace_in_file` or `write_to_file`, do not include comments like `# Renumbered`, `# New item`, or `# Fixed error` in the generated code; these belong in the thought process or commit message.**

**Rationale:**
Temporary or explanatory comments added during modification clutter the code, provide no long-term value, and can become outdated or misleading. Code changes should be understandable through the code itself and commit messages, not through temporary inline annotations.

## Rule: Use Correct PowerShell Output Cmdlets

**Description:**
Select the appropriate cmdlet for script output to prevent errors and ensure proper stream handling.

**Guidelines:**

*   **`Write-Output`**: **Strictly** for function return values intended for assignment or pipeline use.
    *   **AVOID** using it for status messages/prompts within functions that return values. Doing so pollutes the output stream and can cause type errors (e.g., `$var = MyFunc` results in `$var` being `Object[]` instead of `string` because `Write-Output` messages were captured).
*   **`Write-Information`**: **Preferred** for status/progress messages. Controllable via `$InformationPreference` (set to `'Continue'` in main scripts) and redirectable.
*   **`Write-Host`**: Use **only** when direct console display is essential and redirection is undesirable (e.g., `Read-Host` prompts).
*   **`Write-Warning`/`Error`/`Verbose`/`Debug`**: Use for their specific semantic purposes.

**Rationale:**
Prevents type mismatches when capturing function output. Improves script clarity and control over output streams.
