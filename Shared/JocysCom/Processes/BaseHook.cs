using System;
using System.ComponentModel;
using System.Runtime.InteropServices;
namespace JocysCom.ClassLibrary.Processes
{

	internal partial class NativeMethods
	{
		/// <summary>
		/// Used for processing WH_MOUSE and WH_KEYBOARD_LL messages.
		/// </summary>
		internal delegate IntPtr HookProcDelegate(int nCode, IntPtr wParam, IntPtr lParam);

		internal delegate void WinEventProcDelegate(
			IntPtr hWinEventHook,
			uint eventType,
			IntPtr hwnd,
			int idObject,
			int idChild,
			uint dwEventThread,
			uint dwmsEventTime
		);

		/// <summary>Retrieves a module handle for the specified module. The module must have been loaded by the calling process.</summary>
		/// <returns>If the function succeeds, the return value is a handle to the specified module.</returns>
		[DllImport("kernel32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
		internal static extern IntPtr GetModuleHandle(string lpModuleName);

		/// <summary>Installs an application-defined hook procedure into a hook chain.</summary>
		/// <returns>If the function succeeds, the return value is the handle to the hook procedure. </returns>
		[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern IntPtr SetWindowsHookEx(uint hookid, HookProcDelegate pfnhook, HandleRef hinst, uint threadid);

		/// <summary>Installs an application-defined hook procedure into a hook chain.</summary>
		/// <returns>If the function succeeds, the return value is the handle to the hook procedure. </returns>
		[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern IntPtr SetWindowsHookEx(uint hookid, HookProcDelegate pfnhook, IntPtr hinst, uint threadid);

		/// <summary>Removes a hook procedure installed in a hook chain by the SetWindowsHookEx function. </summary>
		/// <returns>If the function succeeds, the return value is non-zero. If the function fails, the return value is zero.</returns>
		[DllImport("user32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		internal static extern bool UnhookWindowsHookEx(HandleRef hhook);

		[DllImport("user32.dll", SetLastError = true)]
		internal static extern IntPtr SetWinEventHook(
			uint eventMin,
			uint eventMax,
			IntPtr hmodWinEventProc,
			WinEventProcDelegate lpfnWinEventProc,
			uint idProcess,
			uint idThread,
			uint dwFlags
		);

		[DllImport("user32.dll", SetLastError = true)]
		internal static extern bool UnhookWinEvent(HandleRef hWinEventHook);

		/// <summary>
		/// Passes the hook information to the next hook procedure in the current hook chain.
		/// A hook procedure can call this function either before or after processing the hook information.
		/// </summary>
		/// <returns>
		/// This value is returned by the next hook procedure in the chain.
		/// The current hook procedure must also return this value.
		/// The meaning of the return value depends on the hook type.
		/// </returns>
		[DllImport("user32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		internal static extern IntPtr CallNextHookEx(HandleRef hhook, int code, IntPtr wparam, IntPtr lparam);

		/// <summary>
		/// Retrieves the identifier of the thread that created the specified window
		/// </summary>
		/// <param name="hWnd">A handle to the window.</param>
		/// <param name="lpdwProcessId">A pointer to a variable that receives the process identifier.</param>
		/// <remarks>When you don't want the ProcessId, use this overload and pass IntPtr.Zero for the second parameter</remarks>
		/// <returns>The return value is the identifier of the thread that created the window.</returns>

		[DllImport("user32.dll", SetLastError = true)]
		internal static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint lpdwProcessId);

		[DllImport("kernel32.dll")]
		internal static extern uint GetCurrentThreadId();

	}

	public class BaseHook : IDisposable
	{

		public bool EnableEvents = true;

		public const uint EVENT_OBJECT_SHOW = 0x8002;
		public const uint EVENT_OBJECT_HIDE = 0x8004;
		public const uint EVENT_OBJECT_NAMECHANGE = 0x800C;
		public const uint EVENT_OBJECT_LOCATIONCHANGE = 0x800B;

		public const uint WINEVENT_OUTOFCONTEXT = 0x0000;
		// Prevents this instance of the hook from receiving the events that are generated by the thread that is registering this hook.
		public const int WINEVENT_SKIPOWNTHREAD = 0x1;
		// Prevents this instance of the hook from receiving the events that are generated by threads in this process.
		public const int WINEVENT_SKIPOWNPROCESS = 0x2;
		public const uint WINEVENT_INCONTEXT = 0x0004;

		public const uint EVENT_SYSTEM_FOREGROUND = 0x0003;


		NativeMethods.HookProcDelegate _Hook1Procedure;

		/// <summary>
		/// Used for processing EVENT_OBJECT_NAMECHANGE messages.
		/// </summary>
		NativeMethods.WinEventProcDelegate _Hook2Procedure;
		NativeMethods.WinEventProcDelegate _Hook3Procedure;

		protected HandleRef _Hook1Handle;
		protected HandleRef _Hook2handle;
		protected HandleRef _Hook3handle;

		public virtual void Start(bool global = false) { throw new NotImplementedException(); }
		public void Stop() { UnInstallHook(); }
		public HookType HookType { get { return _hookType; } }
		private HookType _hookType;

		object HookLock = new object();

		protected void InstallHook(HookType hookType, bool global)
		{
			lock (HookLock)
			{
				_hookType = hookType;
				// If hook is installed already then return.
				if (_Hook1Handle.Handle != IntPtr.Zero)
					return;
				if (_Hook2handle.Handle != IntPtr.Zero)
					return;
				if (_Hook2handle.Handle != IntPtr.Zero)
					return;
				if (hookType == HookType.WH_MOUSE)
				{
					InstalltWindowsHook(ref _Hook1Procedure, ref _Hook1Handle, global, (uint)hookType);
					// Listen for name change changes across all processes/threads on current desktop...
					InstallWinEventHook(ref _Hook2Procedure, ref _Hook2handle, global, EVENT_OBJECT_NAMECHANGE, EVENT_OBJECT_NAMECHANGE);
					InstallWinEventHook(ref _Hook3Procedure, ref _Hook3handle, global, EVENT_OBJECT_SHOW, EVENT_OBJECT_SHOW);
				}
				else if (hookType == HookType.WH_CBT)
				{
					InstallWinEventHook(ref _Hook2Procedure, ref _Hook3handle, global, EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND);
				}
				else
				{
					InstalltWindowsHook(ref _Hook1Procedure, ref _Hook1Handle, global, (uint)hookType);
				}
			}
		}
		private void InstalltWindowsHook(ref NativeMethods.HookProcDelegate procedure, ref HandleRef handle, bool global, uint hookType)
		{
			var lpModuleName = System.Diagnostics.Process.GetCurrentProcess().MainModule.ModuleName;
			var threadId = NativeMethods.GetCurrentThreadId();
			var hMod = NativeMethods.GetModuleHandle(lpModuleName);
			// Assign Virtual function.
			procedure = new NativeMethods.HookProcDelegate(Hook1Procedure);
			// Listen for events.
			var hookHandle = NativeMethods.SetWindowsHookEx(
				hookType,
				procedure,
				hMod,
				global ? 0 : threadId
			);
			if (hookHandle == IntPtr.Zero)
			{
				var ex = new Win32Exception();
				throw new Exception(ex.Message);
			}
			handle = new HandleRef(null, hookHandle);
		}

		private void InstallWinEventHook(ref NativeMethods.WinEventProcDelegate procedure, ref HandleRef handle, bool global, uint eventMin, uint eventMax)
		{
			var lpModuleName = System.Diagnostics.Process.GetCurrentProcess().MainModule.ModuleName;
			var threadId = NativeMethods.GetCurrentThreadId();
			// Assign Virtual function.
			procedure = new NativeMethods.WinEventProcDelegate(Hook2Procedure);
			// Listen for name change changes across all processes/threads on current desktop...
			var hookHandle = NativeMethods.SetWinEventHook(
				eventMin,
				eventMax,
				IntPtr.Zero,
				procedure,
				0,
				// Associate hook procedure with current application/thread only.
				global ? 0 : threadId,
				WINEVENT_OUTOFCONTEXT
			);
			if (hookHandle == IntPtr.Zero)
			{
				var ex = new Win32Exception();
				throw new Exception(ex.Message);
			}
			handle = new HandleRef(null, hookHandle);
		}

		private void UnInstallHook()
		{
			lock (HookLock)
			{
				// If hook is installed then...
				if (_Hook1Handle.Handle != IntPtr.Zero)
					NativeMethods.UnhookWindowsHookEx(_Hook1Handle);
				// If hook is installed then...
				if (_Hook2handle.Handle != IntPtr.Zero)
					NativeMethods.UnhookWinEvent(_Hook2handle);
				// If hook is installed then...
				if (_Hook3handle.Handle != IntPtr.Zero)
					NativeMethods.UnhookWinEvent(_Hook3handle);
			}
		}

		protected virtual IntPtr Hook1Procedure(int nCode, IntPtr wParam, IntPtr lParam)
		{
			throw new NotImplementedException();
			// Return value must be 0 to allow the operation, or 1 to prevent it.
			//return NativeMethods.CallNextHookEx(hook1handleRef, nCode, wParam, lParam);
		}

		protected virtual void Hook2Procedure(
			IntPtr hWinEventHook,
			uint eventType,
			IntPtr hwnd,
			int idObject,
			int idChild,
			uint dwEventThread,
			uint dwmsEventTime
		)
		{
			throw new NotImplementedException();
		}

		#region IDisposable

		// Dispose() calls Dispose(true)
		public void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		//// NOTE: Leave out the finalizer altogether if this class doesn't 
		//// own unmanaged resources itself, but leave the other methods
		//// exactly as they are. 
		//~Encryption()
		//{
		//    // Finalizer calls Dispose(false)
		//    Dispose(false);
		//}

		// The bulk of the clean-up code is implemented in Dispose(bool)
		protected virtual void Dispose(bool disposing)
		{
			if (disposing)
			{
				UnInstallHook();
			}
		}

		#endregion


	}
}
